# -*- coding: utf-8 -*-
"""Assignment_3_server

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bPTSqPmrG7MXV12TV5jwF27HkO-YJr9h
"""

from fastapi import FastAPI, File, UploadFile, HTTPException
import uvicorn
import json
import numpy as np

# Import functions/classes from template files
from graph import Graph
from node import Node
from dijkstra import dijkstra

# create FastAPI app
app = FastAPI()

# global variable for active graph
active_graph: Graph | None = None


@app.get("/")
async def root():
    return {"message": "Welcome to the Shortest Path Solver!"}


@app.post("/upload_graph_json/")
async def create_upload_file(file: UploadFile = File(...)):
    """
    Handles uploading a JSON graph file.
    It reads the file, constructs a Graph object, and stores it globally.
    """
    global active_graph

    # 1. Check for valid file type
    if not file.filename.endswith('.json'):
        raise HTTPException(status_code=400, detail="Upload Error. Invalid file type. Please upload a .json file.")

    try:
        # 2. Read the file content asynchronously
        content = await file.read()
        data = json.loads(content)

        # 3. Create a new graph object (based on logic from your utils.py)
        graph = Graph()

        # 4. Populate the graph
        for row in data:
            source_id = str(row["source"])
            target_id = str(row["target"])
            weight = float(row["weight"])
            bidirectional = bool(row["bidirectional"])

            # Add nodes if they don't exist
            if source_id not in graph.nodes:
                graph.add_node(Node(source_id))
            if target_id not in graph.nodes:
                graph.add_node(Node(target_id))

            # Add the edge
            graph.add_edge(graph.nodes[source_id], graph.nodes[target_id], weight, bidirectional)

        # 5. Set the new graph as the active one
        active_graph = graph

        return {"Upload Success": file.filename}

    except json.JSONDecodeError:
        active_graph = None # Clear graph on bad upload
        raise HTTPException(status_code=400, detail="Error: Invalid JSON format in file.")
    except Exception as e:
        active_graph = None # Clear graph on other errors
        raise HTTPException(status_code=500, detail=f"Failed to process file: {str(e)}")


@app.get("/solve_shortest_path/")
async def get_shortest_path(start_node_id: str, end_node_id: str):
    """
    Solves for the shortest path on the active graph.
    This uses standard query parameters, e.g.:
    .../solve_shortest_path/?start_node_id=0&end_node_id=4
    """
    global active_graph

    # 1. Check if a graph is loaded
    if active_graph is None:
        raise HTTPException(status_code=400, detail="Solver Error. No active graph. Please upload a graph first.")

    # 2. Check if nodes exist in the graph
    if start_node_id not in active_graph.nodes:
        raise HTTPException(status_code=404, detail=f"Solver Error: Start node '{start_node_id}' not found in graph.")
    if end_node_id not in active_graph.nodes:
        raise HTTPException(status_code=404, detail=f"Solver Error: End node '{end_node_id}' not found in graph.")

    # 3. Get the actual node objects
    start_node = active_graph.nodes[start_node_id]
    end_node = active_graph.nodes[end_node_id]

    try:
        # 4. Run Dijkstra's algorithm.
        # Your dijkstra.py function modifies the graph in-place.
        dijkstra(active_graph, start_node)

        # 5. Get the total distance from the end node's 'dist' attribute
        distance = end_node.dist

        path = []

        # 6. Check if a path was found
        if distance == np.inf:
            path = None  # No path exists
        else:
            # 7. Reconstruct the path by following 'prev' pointers
            current_node = end_node
            while current_node is not None:
                path.append(current_node.id)
                current_node = current_node.prev
            path.reverse() # The path was built from end-to-start

            # Final check in case the path doesn't start at the start node
            if path[0] != start_node_id:
                path = None
                distance = np.inf

        return {
            "shortest_path": path,
            "total_distance": distance
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An error occurred during solving: {str(e)}")


if __name__ == "__main__":
    print("Server is running at http://localhost:8080")
    # Note: The 'reload=True' is great for development but should be
    # removed or set to False for production/deployment.
    uvicorn.run("server:app", host="0.0.0.0", port=8080, reload=True)